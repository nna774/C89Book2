\chapter{僕の考えた最強のPiet拡張}

\section{はじめに}

murataと申します．TwitterIDは@paradigm\_9です．
nona7さんと同じくKMC(京大マイコンクラブ)というサークルに所属しています．
今回Pietで一つのサークルとして出店するという@nona7さんの挑戦を聞いて，
「これは寄稿するしかない！」と勢いだけで寄稿します．
僕は強いプログラミングが書けないので，お絵かき的なPietを描いて楽しんでいます．

\section{Pietは凄い！}

今現在様々な言語が世の中にはありますが，
Pietは画像でプログラミングが出来るというとても異彩な言語です．
画像でプログラミングが出来るというのは大変すごいことです．
例えば，一見キャラクターの顔画像にしか見えないのに，
Pietとして実行すると「72CHIHAYA」と出力し続けるものを描いたことがあります．\\\includegraphics{images/0c1bff41d6d4f3358e682af6f3c112c4.png}

rubyが「プログラミングが楽しく出来るように」を， perlが「There's more
than one way to do it(やり方は一つじゃない)」を モットーにしていますが，
Pietは画像でプログラミングが出来るので楽しく，
上記の例のようにプログラミングを表現する絵は自分の好きなように描けますので，
PietはRubyやPerlとおなじコンセプトを持った凄い言語と言えるでしょう！

\section{僕の考えた最強のPiet (Piet\#)}

そんな素晴らしいPietですが，未だに難解プログラミング言語として扱われています．
Piet自体には本当はもっと表現力があるのに\ldots{}．
今回の記事は，そんなPietを拡張してもっともっと実用的な
最強のPiet「Piet\#」の仕様を考えたという記事です．

\section{Piet\#の新機能}

\begin{itemize}
\item
  DLLのインポート
\item
  他のPietのコードの呼び出し
\item
  スタックにスタックを積める
\item
  強力な文字処理機構
\item
  自分の好きな18色によるコーディング
\end{itemize}

\section{Piet\#で新たに出来ること}

\subsection{Webアプリケーションやゲームを簡単に作れる！}

旧Pietでは標準入出力になにかをするので手一杯でした．
しかし，Piet\#では前述のDLLのインポートをサポートしているので，
気軽に素晴らしいプログラミングができます！
更に，他のPietコードを呼び出せるので，
作成した機能はモジュール化することができ，
ライブラリを揃えれば上述のことはたやすく実現できます！

\subsection{高い表現力により自由なコーディングが出来る！}

旧Pietでは数字しかスタックに積めませんでした．
そのため，とても表現力が低かったのです．
しかし，Piet\#では，新たにスタックにスタックを積むことが出来て，
とても表現力豊かなプログラミングが出来ます．
スタックにスタックに，\ldots{}，スタックに，スタックを積むというふうに
無限にスタックにはスタックを積めるので，
木構造のようなデータ構造も再現できます．
また，新たにスタックに積んだスタックを
文字列とみなすことで高度な文字処理が出来る機構も搭載していて，
ファイル処理や高度な文字処理にも耐えうるコーディングが可能となります．

\subsection{楽しく直感的なプログラミングが出来る！}

旧Pietでも楽しくプログラミングが出来たのですが，
コメントの挿入も出来ず，決まった18色しか出来ないなどの成約がありました．
しかし，Piet\#では専用のIDEでそれらをカバーする予定です．
また，Piet\#のプログラミングで本質的に変わったことは，
新たにスタックが積めるようになったことだけなので，
学習コストも少なくて済みます！
Pietがコードとして利用するPNG画像にはメタデータを挿入できることを利用して，
コメントの挿入，好きな18色でのコーディングなどをサポートし，
より快適なプログラミングを目指します！

\section{PietとしてのPiet\#}

Piet\#はあくまでもPietです． 色は18色しか扱わないし，
画像のみがあれば誰でも同じコードを再現できます．
これらを守ることで，Cに対するC++のように，
旧Pietのコードもそのまま動かすことが可能となります．

\section{色の問題}

Piet標準色はチカチカするものばかり\ldots{}
しかも特に青系の色など，違いがわかりにくいものもあります．
Piet\#では，自分で18色を定義できます．
とはいえ，好き勝手定義しては読みにくいですので，指針を．
色相(H)の順序付けが出来て，明度(彩度)の順序付けができればいいですよね．
6色なので，色相は基本的には60度程度違えばよいですね．
色を見分けられるように，30度以上の差を全てが保つ色にしましょう．
明度と彩度でSVの三角形は，色が分かるように， 0.5 \textless{} V \textless{}
1 ，0.2 \textless{} S \textless{}= 1であるという条件のもと，
V，Sを変えればすきな組み合わせに出来ますね．

\section{Piet\#としての情報の保存方法}

Piet\#(Pietも！)が実行するコードはPNGファイルです．
実はPNGにはメタデータを入れることが出来ます．
Piet\#のIDEではコメントを挿入することが出来ます．
また，前述のとおり18色の指定も出来ます．
そのほかにも，IDEとして保存しておきたい情報は数多くあります．
それも全てこのメタデータに保存すればよいですね．

\section{記法の定義}

今までの項でPiet\#の新たな機能を見ました．
以降の項でPiet\#の具体的な仕様を見ていくことにしましょう．
まずは記法の定義から見ていきましょう． DirectionPointerをDPと略します．
CodelChooserをCCと略します．

空のスタックに順番に， \textbf{1 をPush， 2 をPush， 3 をPush， 4 をPush}
した時， スタックの変化を \textbf{{[}{]} $\to$ {[}1{]}
$\to$ {[}1,2{]} $\to$ {[}1,2,3{]} $\to$
{[}1,2,3,4{]}} と表記します．
つまり，一番右にあるものが一番最近Pushしたものとなります．

また， \textbf{{[}1,2,3,4{]}} にAdd命令を行うことを， \textbf{Add
{[}1,2,3,4{]} $\to$ {[}1,2,7{]}} と表記できます． この場合，1,2
は直接演算に関係ないので， \textbf{Add {[}\ldots{},3,4{]} $\to$
{[}\ldots{},7{]}} のように記すことができます． さらに演算に関係ない項目
\textbf{\ldots{}} を省略し，以降の文章では \textbf{Add {[}3,4{]}
$\to$ {[}7{]}} のように記します． 例えば，Sub{[}7,2{]}
$\to$ {[}5{]} は，7 - 2 = 5 をしたことを意味しますね．

また，Piet\#では前述のとおり数字とスタックのみで構成されています．
しかし，文字処理のために糖衣構文を定義しておきます． まず，65 =``A''; 66
=``B'';67 =``C'';とUnicodeで対応しています． 文字処理のために
{[}65,66,67{]} と積んだ場合，
その数字が何を指しているかで表現したほうが見やすいので， {[}65,66,67{]} =
{[}A,B,C{]} と表記しましょう． さらにもっと省略して，{[}A,B,C{]} = ``ABC''
という糖衣構文も定義します． Piet\#
では数字とスタックしか使わないということは
大事なことなので忘れないでください．　　

\section{モジュール呼び出しとスタック型の導入}

Piet\#では新たに２つの命令を導入します．
既存のPietと競合しないように導入しなければなりません．
そこで，普通しない命令である 0除算命令，0剰余命令に
新たな命令としての意味を持たせるという形で導入します．

\paragraph{モジュール呼び出し}

\textbf{Div {[}n,0{]} $\to$ {[}{]}}\\\textbf{n.png
という名前のPietを読み込んで実行します．}\\現在の標準入力，標準出力，スタックのまま，
そしてDP は 0 ，CC は 1 で初期化されて
そのPietを一番左上の位置から実行します．
終了後，退避されていたDP，CCは元に戻ります．
この命令によりファイルをモジュール化でき，
ファイルの分割が可能になります．
また，言語としての強さの要素である標準ライブラリを搭載し
簡単にこの命令でアクセス出来るように，
nが負の場合は標準ライブラリから探すというふうにする予定です．

\paragraph{スタックの新規作成}

\textbf{Mod {[}\ldots{},x1,x2,\ldots{},xn,n,0{]} $\to$
{[}\ldots{},{[}x1,x2,\ldots{},xn{]}{]}}\\\textbf{深さnまでの要素を積んだ新たなスタックをPushします}\\この関数により，Piet\#のスタックに，
新たなスタックを積むことが出来るようになります\\例： Mod
{[}\ldots{},C,H,Y,3,0{]} $\to$ {[}\ldots{},{[}C,H,Y{]}{]}

\section{スタック演算}

今回の拡張によって数字だけでなくスタックも積めるようになりました．
スタック同士の演算を新たに定義しましょう．
スタックとスタック，数字と数字との演算なら問題はないのですが，
スタックと数字が混じっていた場合についてはちょっと考えないといけません．
結論としては，その数字を一つのみを積んだ新たなスタックを作成して，
それを利用してスタックとスタックの演算として扱います．

例えば，加算の関数 Add は， \textbf{Add {[}\ldots{},72,28{]}
$\to$ {[}\ldots{},100{]}} と，数字同士なら演算されますが，
スタック同士に Add を作用させると結合の意味になります．\\例：) \textbf{Add
{[}\ldots{},{[}A,B,C{]},{[}X,Y{]}{]} $\to$
{[}\ldots{},{[}A,B,C,X,Y{]}{]}}\\そして，数字とスタックの演算の場合は，
その数字を一つのみを積んだ新たなスタックを作成して，
それを利用してスタックとスタックの演算として扱うので， \textbf{Add
{[}\ldots{},C,{[}H,Y{]}{]} $\to$ Add
{[}\ldots{},{[}C{]},{[}H,Y{]}{]} $\to$
{[}\ldots{},{[}C,H,Y{]}{]}} と計算されます．

それでは早速命令を見ていきましょう！

\subsection{ゼロ引数関数}

Push ， In(char) ， In (number) はスタックとしては定義されません．

\subsection{一引数関数}

スタックの先頭から一つとり，それに演算を適用します．

\paragraph{Switch: 平坦化する (Flatten)}

型 :: {[}\ldots{}{]} $\to$
{[}\ldots{}{]}\\スタックにスタックが積まれて，更にそれにスタックが\ldots{}という状態に
陥いったときにそれを全て平坦化してくれます． 例を見てみますよ．

\begin{itemize}
\item
  Switch {[}\ldots{},{[}A,{[}B,C,{[}D{]},E{]},F,G{]}{]} $\to$
  {[}\ldots{},{[}A,B,C,D,E,F,G{]}{]}
\item
  Switch {[}\ldots{},{[}A,B,C{]}{]} $\to$
  {[}\ldots{},{[}A,B,C{]}{]}
\item
  Switch {[}\ldots{},{[}A{]}{]} $\to$ {[}\ldots{},{[}A{]}{]}
\item
  Switch {[}\ldots{},{[}{]}{]} $\to$ {[}\ldots{},{[}{]}{]}
\end{itemize}

\paragraph{Point : スタックの先頭を取得する}

型 :: {[}\ldots{},T{]} $\to$ {[}\ldots{}{]}，
T\\スタックの先頭要素を一つとりだしてPushします．例をあげましょう．

\begin{itemize}
\item
  Point {[}\ldots{},{[}A,B,C{]}{]} $\to$
  {[}\ldots{},{[}A,B{]},C{]}
\item
  Point {[}\ldots{},{[}A,B,C,{[}X,Y{]}{]}{]} $\to$
  {[}\ldots{},{[}A,B,C{]},{[}X,Y{]}{]}
\item
  Point {[}{[}{[}Xn,Yn{]},\ldots{},{[}X1,Y1{]}{]}{]} $\to$
  {[}{[}{[}Xn,Yn{]},\ldots{},{[}X2,Y2{]}{]},{[}X1,Y1{]}{]}
\item
  Point {[}\ldots{},{[}A{]}{]} $\to$ {[}\ldots{},{[}{]},A{]}
\item
  Point {[}{[}{]}{]} $\to$ {[}{]}
\end{itemize}

\paragraph{Dup: コピーする (Duplicate)}

型 :: {[}\ldots{}{]} $\to$ {[}\ldots{}{]},{[}\ldots{}{]}
数字版のDupと同じです．例を見せます．

\begin{itemize}
\item
  Dup {[}\ldots{},{[}{[}1,3,4{]},4,32{]}{]} $\to$
  {[}\ldots{},{[}{[}1,3,4{]},4,32{]},{[}{[}1,3,4{]},4,32{]}{]}
\end{itemize}

\paragraph{Not: スタックの中身が空の時 1 を，それ以外では 0 を返す}

型 :: {[}\ldots{}{]} $\to$
Num\\数字版のNotと意味的には一緒です．
NotとSwitchを組み合わせることで条件分岐に使用出来ますね．

\begin{itemize}
\item
  Not {[}``Hello''{]} $\to$ {[}0{]}
\item
  Not {[}{[}A{]}{]} $\to$ {[}0{]}
\item
  Not {[}{[}{]}{]} $\to$ {[}1{]}
\end{itemize}

\paragraph{Pop: 捨てる}

型 :: {[}\ldots{}{]} $\to$
{[}{]}\\数字版のPopと一緒です．例を一応載せときます．

\begin{itemize}
\item
  Pop {[}{[}A,B,C{]}{]} $\to$ {[}{]}
\end{itemize}

\paragraph{Out(Char) : 文字列として出力する}

型 :: {[}\ldots{}{]} $\to$ {[}{]}\\
Switchで平坦化して文字列と見なせるようにしてから出力します．

\begin{itemize}
\item
  Out(Char) {[}{[}C,H,Y{]}{]} $\to$ {[}{]} : ``CHY''と出力する
\item
  Out(Char) {[}{[}千,早{]}{]} $\to$ {[}{]} :
  ``千早''と出力する
\item
  Out(Char) {[}{[}C,{[}H,I,{[}H,A{]},Y{]},A{]}{]} $\to$ {[}{]}
  : ``CHIHAYA''と出力する
\item
  Out(Char) {[}{[}C{]}{]} $\to$ {[}{]} : ``C'' と出力する．
\item
  Out(Char) {[}{[}{]}{]} $\to$ {[}{]} : 何も出力しない．
\end{itemize}

\paragraph{Out(Num) : スタックの中身を全て取り出し，先頭に要素数を積む}

型 :: {[}Tn,\ldots{},T1{]} $\to$ Tn,\ldots{},T1,Num\\Out(Num)
という名前ですが出力はしませんので注意して下さい．
Mod0命令の逆演算となります．

\begin{itemize}
\item
  Out(Num) {[}\ldots{},{[}A,B,C{]}{]} $\to$
  {[}\ldots{},A,B,C,3{]}
\item
  Out(Num) {[}\ldots{},{[}A,{[}B,C{]},D{]}{]} $\to$
  {[}\ldots{},A,{[}B,C{]},D,3{]}
\item
  Out(Num) {[}\ldots{},{[}A{]}{]} $\to$ {[}\ldots{},A,1{]}
\item
  Out(Num) {[}\ldots{},{[}{]}{]} $\to$ {[}\ldots{},0{]}
\end{itemize}

\paragraph{Div 0: モジュール呼び出し}

Div 0 の 被除数が スタックの場合，それをSwitchで平坦化して
文字列にし，その文字列のパスにあるPietモジュールを実行します．

\paragraph{Mod 0 : スタックの新規作成}

Mod {[}\ldots{},x1,x2,\ldots{},xn,n,0{]} $\to$
{[}\ldots{},{[}x1,x2,\ldots{},xn{]}{]}\\深さnまでの要素を積んだ新たなスタックをPushします．
x1,\ldots{},xn がスタック型であっても大丈夫です． n
がスタックであった場合は n = ∞ として(つまり深さ無限で)演算します．

\begin{itemize}
\item
  Mod {[}\ldots{},C,H,Y,3,0{]} $\to$
  {[}\ldots{},{[}C,H,Y{]}{]}
\item
  Mod {[}\ldots{},{[}C,H,I{]},{[}H,A,Y,A{]},2,0{]} $\to$
  {[}\ldots{},{[}{[}C,H,I{]},{[}H,A,Y,A{]}{]} {]}
\item
  Mod {[}\ldots{},C,H,Y,{[}{]},0{]} $\to$
  {[}{[}\ldots{},C,H,Y{]}{]}
\end{itemize}

\subsection{二引数関数}

スタックの先頭から２つとり，それらに演算を適用します．

\paragraph{Add: 結合する (Append)}

型 :: {[}\ldots{}{]},{[}\ldots{}{]} $\to$
{[}\ldots{}{]}\\単純に結合します．例を示します． {[}A,B,C{]} =``ABC''
という糖衣構文を思い出してくださいね．

\begin{itemize}
\item
  Add {[}\ldots{},{[}C,H,I{]},{[}h,a,y,a{]}{]} $\to$
  {[}\ldots{},{[}C,H,I,h,a,y,a{]}{]}
\item
  Add {[}\ldots{},``CHIhaya'',``isGOD'') $\to$
  {[}\ldots{},``CHIhayaisGOD''{]}
\item
  Add {[}\ldots{},1,{[}10,100,1000{]}{]} $\to$
  {[}\ldots{},{[}1,10,100,1000{]}{]}
\item
  Add {[}\ldots{},{[}1,10,100{]},1000{]} $\to$
  {[}\ldots{},{[}1,10,100,1000{]}{]}
\item
  Add {[}\ldots{},{[}A,B,C{]},{[}{]}{]} $\to$
  {[}\ldots{},{[}A,B,C{]}{]}
\item
  Add {[}\ldots{},{[}{]},{[}{]}{]} $\to$ {[}\ldots{},{[}{]}{]}
\end{itemize}

\paragraph{Sub: 正規表現で分割する (Split)}

型 :: {[}\ldots{}{]},{[}\ldots{}{]} $\to$
{[}\ldots{}{]}\\Switch
で平坦化し，文字列として見なせるようにしてからSplitします． {[}A,B,C{]}
=``ABC'' という糖衣構文を思い出してくださいね．

\begin{itemize}
\item
  Sub {[}\ldots{},``Pietはx楽しい'',``x''{]}$\to$
  {[}\ldots{},{[}``Pietは'',``楽しい''{]}{]}
\item
  Sub {[}``12/12 21:41''," \textbar{}/\textbar{}:``{]} $\to$
  {[}{[}''12``,''12``,''21``,''41"{]}{]}
\item
  Sub {[}\ldots{},``helloHWWH!'',H{]} $\to$
  {[}\ldots{},{[}``hello'',{[}W,W{]},{[}!{]}{]}{]}
\item
  Sub {[}\ldots{},{[}h,{[}e,H{]},{[}l,l,{[}{[}o{]}{]}{]}{]},{[}H{]}
  $\to$ {[}\ldots{},{[}``he'',``llo''{]}{]}
\item
  Sub {[}\ldots{},H,``\\s''{]} $\to$ {[}\ldots{},{[}H{]}{]}
\item
  Sub {[}\ldots{},H,``H''{]} $\to$ {[}\ldots{},{[}{]}{]}
\end{itemize}

\paragraph{Mul: 直積集合を取得する}

型 :: {[}\ldots{}{]},{[}\ldots{}{]} $\to$
{[}\ldots{}{]}\\便利な未来を作る直積集合ですよ．

\begin{itemize}
\item
  Mul {[} {[}A,B,C{]},{[}X,Y{]} {]} $\to$ {[}
  {[}{[}A,X{]},{[}A,Y{]},{[}B,X{]},{[}B,Y{]},{[}C,X{]},{[}C,Y{]}{]} {]}
\item
  Mul {[}\ldots{},H,{[}J,I{]}{]} $\to$ {[}\ldots{}, {[}
  {[}H,J{]},{[}H,I{]} {]} {]}
\item
  Mul {[}\ldots{},{[}A{]},H{]} $\to$ {[}\ldots{},{[}A,H{]}{]}
\item
  Mul {[}\ldots{},{[}{]},A{]}$\to$ {[}\ldots{},{[}{]}{]}
\item
  Mul {[}{[}A,B,C{]},{[}{[}X,Y{]}{]}{]} $\to$
  {[}{[}A,{[}X,Y{]}{]},{[}B,{[}X,Y{]}{]},{[}C,{[}X,Y{]}{]}{]}
\item
  これにより，例えば 0 \textless{} n,m $\leq$ 20 の n * m
  の取りうる値を列挙できます
\end{itemize}

\begin{itemize}
\item
  1〜20までと20と0を順に積む $\to$ {[}1,\ldots{},20,20,0{]}
\item
  Mod0 を実行してスタック化 $\to$ {[}{[}1,\ldots{},20{]}{]}
\item
  Dupでコピーを作成 $\to$
  {[}{[}1,\ldots{},20{]},{[}1,\ldots{}20{]}{]}
\item
  Mul で直積を取る $\to$
  {[}{[}{[}1,1{]},\ldots{},{[}20,20{]}{]}{]}
\item
  Point で先頭の要素を取得 $\to$
  {[}{[}{[}1,1{]},\ldots{},{[}20,19{]}{]},{[}20,20{]}{]}
\item
  Out(N)で分解する $\to$
  {[}{[}{[}1,1{]},\ldots{},{[}20,19{]}{]},20,20,2{]}
\item
  2 を Pop $\to$
  {[}{[}{[}1,1{]},\ldots{},{[}20,19{]}{]},20,20{]}
\item
  Mulで掛け算する $\to$
  {[}{[}{[}1,1{]},\ldots{},{[}20,19{]}{]},400{]}
\item
  Roll 2 1 で入れ替える $\to$
  {[}400,{[}{[}1,1{]},\ldots{},{[}20,19{]}{]}{]}
\item
  5\textasciitilde{}9 を繰り返す．
\item
  {[}400,\ldots{},1{]} が出来上がる．
\end{itemize}

\paragraph{Div: 正規表現でマッチさせる (Match)}

型 :: {[}\ldots{}{]},{[}\ldots{}{]} $\to$
{[}\ldots{}{]}\\Switch
で平坦化し，文字列として見なせるようにしてからMatchします． {[}A,B,C{]}
=``ABC'' という糖衣構文を思い出してくださいね．

\begin{itemize}
\item
  Div {[}``aa9bb1cc'',``.{[}1-9{]}.''{]} $\to$
  {[}{[}``a9b'',``b1c'',``aa9bb1cc''{]}{]}
\item
  Div {[}``aa'',``.{[}1-9{]}.''{]} $\to$ {[}{[}{]}{]}
\item
  Div {[}``aHxH'',H{]}$\to$ {[}{[}``H'',``H'',``aHxH''{]}{]}
\item
  Div {[}H,``h\textbar{}H''{]} $\to$ {[}{[}``H'',``H''{]}{]}
\item
  Div {[}{[}{]},``A\textbar{}B''{]} $\to$ {[}{[}{]}{]}
\item
  Div {[}``ABC'',{[}{]}{]} $\to$ {[}{[}{]}{]}
\end{itemize}

\paragraph{Mod: スタックを順番に結合する (Combine)}

型 :: {[}\ldots{}{]},{[}\ldots{}{]} $\to$
{[}\ldots{}{]}\\それぞれの要素を結合します．Mulと上手く組み合わせてご使用下さい．

\begin{itemize}
\item
  Mod {[}``01234'',``abc''{]} $\to$
  {[}{[}``2a'',``3b'',``4c''{]}{]}
\item
  Mod {[}{[}a,b,c,d,e{]},{[}x,y{]}{]} $\to$
  {[}{[}{[}d,x{]},{[}e,y{]}{]}{]}
\item
  Mod {[}{[}{[}a,b,c{]},{[}d,e{]}{]},{[}x,y{]}{]} $\to$
  {[}{[}{[}{[}a,b,c{]},x{]},{[}{[}d,e{]},y{]}{]}{]}
\item
  Mod {[}H,``abc''{]}$\to$ {[}{[}H,c{]}{]}
\item
  Mod {[}``abc'',H{]}$\to$ {[}{[}c,H{]}{]}
\item
  Mod {[}``abc'',{[}{]}{]}$\to$ {[}{[}{]}{]}
\item
  Mod {[}{[}{]},{[}{]}{]}$\to$ {[}{[}{]}{]}
\end{itemize}

\paragraph{Greater: ファイルを読み書きする}

型 :: {[}\ldots{}{]},{[}\ldots{}{]} $\to$
Num\\ファイルを開いて標準入出力へリダイレクトします． 成功したら 1
，失敗したら 0 が積まれます． 第一引数は開くファイル名です．
第二引数は開くモードを指定します．\\\textbf{モード}

\begin{itemize}
\item
  {[}R{]} or {[}r{]} or {[}0{]} : 読み込み(Read)モードで開く．
\item
  {[}W{]} or {[}w{]} or {[}1{]} : 書き込み(Write)モードで開く．
\item
  {[}A{]} or {[}a{]} or {[}2{]} : 追加書き込み(Append)モードで開く
\item
  {[}CR{]} or {[}cr{]} or {[}3{]} : Readで開いたファイルを閉じる．
\item
  {[}Cw{]} or {[}cw{]} or {[}4{]} : Writeで開いたファイルを閉じる．
\item
  その他 : 現在開いているファイルをRead，Writeともに閉じる．
\end{itemize}

新たにファイルを開いた場合，現在開いているファイルは閉じられます．
例を示します．

\begin{itemize}
\item
  Greater {[}``f1.txt'',r{]} $\to$ {[}1{]} :
  f1.txtを開き標準入力をリダイレクトする
\item
  Greater {[}``f2.txt'',1{]} $\to$ {[}1{]} :
  f2.txtを開き標準出力をリダイレクトする
\item
  Greater {[}``f.t'',r{]} $\to$ {[}0{]} : f.tが開けなかった．
\item
  \begin{description}
  \item[Greater {[}``f3.txt'',a{]} $\to$ {[}1{]}]
  2.で開いていたf2.txtを閉じて新たにf3.txtを
  \end{description}

  追加書き込みモードで開き，標準出力をリダイレクトする．
\item
  Greater {[}{[}{]},{[}cr{]}{]} $\to$ {[}0{]} :
  1.で開いていたf1.txtを閉じる．
\end{itemize}

\subsection{四引数関数}

\subsection{Roll: Dllを読み込む}

型 :: {[}\ldots{}{]},{[}\ldots{}{]},{[}\ldots{}{]},{[}\ldots{}{]}
$\to$ Num or {[}\ldots{}{]} or
Empty\\Pietが何でも出来るようになる魔法の関数です．
この関数により，ゲームやアプリを作ることが出来るようになります．
実用的なマルチメディアな操作をPietで体感しよう！\\\textbf{引数}\\第一引数
: DLLへのファイル名を含むパス\\第二引数 : DLL内の関数名\\第三引数 :
DLLに渡される型の宣言\\第四引数 :
DLLを呼び出すための引数リスト\\\textbf{例}

\begin{itemize}
\item
  Roll {[}``user32.dll'',``MessageBoxA'', ``vssui'', {[}{[}{]},``Hello
  World.'',``Caption'',0{]}{]}\\C製Dllであるuser32.dllの，MessageBoxA関数を呼び出します．
  ``vssui''というのは的確にDLLを扱う為の型情報の宣言です．
  引数の型は前から順に void*(HANDLE),char(LPSTR),
  char*(LPSTR),unsigned int (UINT) で，
  返り値はint型にするという宣言で，
  前から順にvoid*,char*,char*,unsigned int,intなので 頭文字をとって
  ``vssui''です．
\item
  Roll
  {[}``TestDLL.dll'',``TestDll.CsDll.LangA'',0,{[}123,``RA''{]}{]}\\自作.Net製DllでTestDll.CsDll.LangA(123,``RA'')を実行します．
  第二引数は NAMESPACE.CLASSNAME.STATICFUNCTIONNAME とします．
  .Net製Dllは型情報が内蔵されているために，
  型を推論することができ，第三引数は省略できます．
  　というか，型を書いても無視されます．
  C製Dllで扱えるプリミティブな型以外はサポートしません．
\end{itemize}

\subparagraph{DLL読み込みの型}

Pietの最強のIDEであるPidetがC\#製なので
Piet\#のIDE，実行ファイルもC\#製です． そのため，内部的にはC\#で処理します．
型の相互変換表は下のようになります．

\begin{table}[htb]
    \begin{tabular}{llll}
      Pietでの型 & Cでの型 & Cでの別名 & C\#での型 \\ \hline \hline
      Number & int,long & INT,LONG,BOOL & int \\
      Number & unsigned int,unsigned long & UINT,DWORD,ULONG & uint \\
      Number & unsigned char & BYTE & byte \\
      Number & char & CHAR &char \\
      Number & unsigned short & WORD &ushort \\
      Number & short & SHORT & short \\
      Number & float & FLOAT & float \\
      Stack & char* & LPSTR,LPWSTR & string \\
      Stack & void* & HANDLE & IntPtr
    \end{tabular}
\end{table}

\section{実装}

ここまで，仕様を詳細に示してきました． あとは実装するだけですね！
C\#で書かれたPidetがあるのでそれをforkして作りたいと思います． Piet\#.exe
を実行すれば出来るようにしたいですね．
スクリプト言語としてのPietとなって， Perl,PHP,Python,Piet\# の
4Pとなることを願っています．
このPiet\#プロジェクトは，ここまでの基本仕様が出来た時点で公開します．
オープンソースプロジェクトとして，
公開後は標準ライブラリの実装のContributeをお待ちしております！ 最新情報は
Github : Muratam, Twitter : paradigm\_9 を参照下さい！
